---
title: "Predicting Bitcoin and Etherium prices"
author: "Michał Szałanski"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	warning = FALSE,
	comment = '      ',
	fig.width = 16,
	fig.height = 9
)
```

# Abstract

# Aim of the study
This study tries to create optimal models for predicting Bitcoin and Etherum
prices by creating optimized ARIMA models, testing currency cointegration 
and finally creating a VAR model.

# Data

```{R libraries, message = FALSE, warning = FALSE, error = FALSE}
### Preparation
# Libraries
library(tidyverse)
library(ggplot2) # nice plots
library(ggthemes) 
library(ggtech) # For the airbnb theme

library(xts)
library(lmtest)
library(tseries)
library(urca)
library(fUnitRoots)
library(quantmod)
library(fBasics)
library(forecast)
library(vars)
library(Metrics)

# For better plotting
theme_set(theme_airbnb_fancy())
orange = "#FFB400"
purple = "#7B0051"

# Fix for the month shorthands
invisible(Sys.setlocale("LC_ALL","English"))

### Data downloading
btc <- read_csv('data/btc.csv')
eth <- read_csv('data/eth.csv')

source("functions.R")
```

```{r data_download}
btc %>% tail
```

```{r }
summary(btc)
```

```{r }
summary(eth)
```

```{r plot_btc}
btc %>%
	ggplot(aes(Date, Close)) +
	geom_area(fill = orange, color = orange, alpha = 0.5) +
	labs(title = "Bitcoin historical prices") +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```

```{r plot_eth}
eth %>%
	ggplot(aes(Date, Close)) +
	geom_area(fill = orange, color = orange, alpha = 0.5) +
	labs(title = "Etherium historical prices") +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```

```{r plot_both}
btc$source <- 'Bitcoin'
eth$source <- 'Etherium'

btc$ClosePercent <- btc$Close / max(btc$Close)
eth$ClosePercent <- eth$Close / max(eth$Close)


bind_rows(btc, eth) %>%
	ggplot(aes(Date, 
			   ClosePercent,
			   color = source)) +
	geom_line() +
	scale_color_manual(values = c(orange, purple)) +
	labs(title = "Close price as % of max price for each coin") +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```


```{r plot_both_2}
bind_rows(btc, eth) %>%
	ggplot(aes(Date, ClosePercent)) +
	geom_line(color = orange) +
	labs(title = "Close price as % of max price for each coin",
		 subtitle = 'Colored only the difference') +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```

```{r }
data <- data.frame(
	date = btc$Date,
	btc  = btc$Close,
	eth  = eth$Close
)

remove(btc)
remove(eth)  

data$Dbtc <- diff.xts(data$btc)
data$Deth <- diff.xts(data$eth)

# Drop the first row with NAs
data <- data %>% drop_na()

# Extract last 30 days for predictions
data_test <- data %>% tail(30)

# Remove them to avoid look ahead bias
data <- data %>% head(-30) # So usefull
```


# ARIMA
## Bitcoin


```{r }
testdf(variable = data$btc,
	   max.augmentations = 5)
```


```{r }
testdf(variable = data$Dbtc,
	   max.augmentations = 5)
```

```{r plot_arima_btc}
par(mfrow = c(2, 1)) 
acf(data$Dbtc,
	lag.max = 36, 
	ylim = c(-0.1, 0.1),    
	lwd = 5,               
	col = orange) 

pacf(data$Dbtc, 
	 lag.max = 36, 
	 lwd = 5,
	 col = orange)
par(mfrow = c(1, 1))
```


```{r armia_btc}
BTC.arima2010.small <- Arima(data$btc,  
					  		order = c(20, 1, 0),
							fixed = c(
								NA, #1
								rep(0, 7),
								NA, #9
								rep(0, 8),
								NA, # 18
								0,
								NA # 20
							)
)
```


```{r }
coeftest(BTC.arima2010.small)
```


```{r }
plot(resid(BTC.arima2010.small))
```


```{r double_plot_arima}
par(mfrow = c(2, 1)) 
acf(resid(BTC.arima2010.small), 
	lag.max = 36,
	ylim = c(-0.1, 0.1), 
	lwd = 5, col = orange,
	na.action = na.pass)
pacf(resid(BTC.arima2010.small), 
	 lag.max = 36, 
	 lwd = 5, col = orange,
	 na.action = na.pass)
par(mfrow = c(1, 1))

```


```{r }
Box.test(resid(BTC.arima2010.small), type = "Ljung-Box", lag = 10)
```

## Etherium

```{r }
testdf(variable = data$eth,
	   max.augmentations = 5)
```

```{r }
testdf(variable = data$Deth,
	   max.augmentations = 5)
```

```{r plot_arima_eth}
par(mfrow = c(2, 1)) 
acf(data$Deth,
	lag.max = 36, 
	ylim = c(-0.1, 0.1),    
	lwd = 5,               
	col = orange) 

pacf(data$Deth, 
	 lag.max = 36, 
	 lwd = 5,
	 col = orange)
par(mfrow = c(1, 1)) 
```

```{r arima_eth}
ETH.arima5120.small <- Arima(data$eth,  
							order = c(5, 1, 20),
							fixed = c(
								rep(0,3),
								NA,
								NA,
								rep(0, 3),
								NA,
								NA,
								rep(0, 3),
								NA,
								0,
								0,
								rep(0, 8),
								NA
							)
)

coeftest(ETH.arima5120.small)
```

```{r }
plot(resid(ETH.arima5120.small))
```

```{r double_plot_eth}
par(mfrow = c(2, 1)) 
acf(resid(ETH.arima5120.small), 
	lag.max = 36,
	ylim = c(-0.1, 0.1), 
	lwd = 5, col = orange,
	na.action = na.pass)
pacf(resid(ETH.arima5120.small), 
	 lag.max = 36, 
	 lwd = 5, col = orange,
	 na.action = na.pass)
par(mfrow = c(1, 1))

```

```{r }
Box.test(resid(ETH.arima5120.small), type = "Ljung-Box", lag = 10)
```


# ARIMA forecasting

```{r arima_forecast_btc}
forecast(BTC.arima2010.small, h = 30) %>%                  # Forecast
	{data.frame(f_mean  = as.numeric(.$mean),              # Make into a DF
			   f_lower = as.numeric(.$lower[, 2]),
			   f_upper = as.numeric(.$upper[, 2]))} %>%
	cbind(data_test) %>%                                   # Add the real data
	ggplot(aes(x = date)) +                                # Plot
		geom_line(aes(y = btc), color = purple) +
		geom_line(aes(y = f_mean), color = orange) +
		geom_line(aes(y = f_lower), color = 'red') +
		geom_line(aes(y = f_upper), color = 'red') +
		labs(title = "30 day prediction of BTC",
			 subtitle = 'Yellow is the prediction') +
		theme(
			text = element_text(family = "sans"), # Remove the font warnings
			plot.title = element_text(family = "sans")
		)
```

```{r arima_forecast_eth}
forecast(ETH.arima5120.small, h = 30) %>%                  # Forecast
	{data.frame(f_mean  = as.numeric(.$mean),              # Make into a DF
				f_lower = as.numeric(.$lower[, 2]),
				f_upper = as.numeric(.$upper[, 2]))} %>%
	cbind(data_test) %>%                                   # Add the real data
	ggplot(aes(x = date)) +                                # Plot
	geom_line(aes(y = eth), color = purple) +
	geom_line(aes(y = f_mean), color = orange) +
	geom_line(aes(y = f_lower), color = 'red') +
	geom_line(aes(y = f_upper), color = 'red') +
	labs(title = "30 day prediction of ETH",
		 subtitle = 'Yellow is the prediction') +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```

# Cointegration testing

Since Bitcoin and Etherium are both integrated of 
order I(1), they could be cointegrated with each other.    

To test this cointegration, a simple 
linear model can be estimated. The coefficient for eth 
is very significant, which means that they are in fact cointegrated.    

It seems that a increase in price of ETH by 1 USD means 
increase od BTC price by around 37 USD.    

```{r lm}
# BTC and ETH are I(1)
model.coint <- lm(btc ~ eth, 
				  data = data)

summary(model.coint)
```

But, are the residuals autocorrelated?   

Yes, they are autocorrelated of order one. This means that lagged 
residuals need to be included in the model.  

```{r }
testdf(variable = residuals(model.coint), 
	   max.augmentations = 3)

```

The inclusion of lagged residuals seem to be a good
decision. The coefficient is significant, which 
hints taht there is a long term relationship
between this variables in addition to the short term one
(indicated by the eth).   

```{r better_lm}
data$lresid <- lag.xts(residuals(model.coint))
model.ecm <- lm(btc ~ eth + lresid,
				data = data) 
summary(model.ecm)
```

Granger test confirms that for 5 lags, there exist a 
Granger Casuality eth -> btc.   

```{r }
grangertest(btc ~ eth, 
			data = data,
			order = 5) 
```

The same results for the other direction. 
Significant Granger Casuality for btc -> eth.   

```{r }
grangertest(eth ~ btc, 
			data = data,
			order = 5)
```



# VAR model
*VARselect* function is very usefull when searching for the right number of lags in the VAR model.
Here, the optimal number seem to be 7 lags, based on AIC and FPE. Could also be 1, 
but that is not very interesting. 
```{r var}
VARselect(data[ , c('btc', 'eth')], # input data for VAR
		  lag.max = 10)     # maximum lag
```

A large number of variables are significant for p < 0.05.
Especially lags 3 and 4 seem to be important for this model. 


```{r }
var.model <- VAR(data[ , c('btc', 'eth')], p = 7)
summary(var.model)
```

Portmanteau test is on the verge of significance,
so another test is needed.

```{r }
serial.test(var.model)
```

Breusch-Godfrey test finds no reason to 
reject the null hyphotesis that the residuals 
are not autocorrelated.

```{r }
serial.test(var.model, type = "BG")
```

# Forecasting VAR
The 30 day forecast for Bitcoin using the VAR model is very close to 
the real values. Because the currency did not move significantly 
the predictions are also very stable. In some sense they 
even look like a simple linear regression, but this is only due to the previous prices.     

```{r forecast_var_btc}
# Forecast for 30 days
var.forecast <- predict(var.model, n.ahead = 30, ci = 0.95) 

# Bitcoin
var.forecast[["fcst"]][["btc"]] %>%
	as.data.frame() %>%
	dplyr::select(f_mean = fcst,
		   		  f_lower = lower,
		          f_upper = upper) %>%
	cbind(data_test) %>%                                   # Add the real data
	ggplot(aes(x = date)) +                                # Plot
	geom_line(aes(y = btc), color = purple) +
	geom_line(aes(y = f_mean), color = orange) +
	geom_line(aes(y = f_lower), color = 'red') +
	geom_line(aes(y = f_upper), color = 'red') +
	labs(title = "30 day prediction of BTC",
		 subtitle = 'Yellow is the prediction') +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```


Same story with Etherium. The predictions are very stable, but they do follow the 
general trend in the data. They also look kind of like a linear reggresion.      


```{r forecast_var_eth}
var.forecast[["fcst"]][["eth"]] %>%
	as.data.frame() %>%
	dplyr::select(f_mean = fcst,
				  f_lower = lower,
				  f_upper = upper) %>%
	cbind(data_test) %>%                                   # Add the real data
	ggplot(aes(x = date)) +                                # Plot
	geom_line(aes(y = eth), color = purple) +
	geom_line(aes(y = f_mean), color = orange) +
	geom_line(aes(y = f_lower), color = 'red') +
	geom_line(aes(y = f_upper), color = 'red') +
	labs(title = "30 day prediction of ETH",
		 subtitle = 'Yellow is the prediction') +
	theme(
		text = element_text(family = "sans"), # Remove the font warnings
		plot.title = element_text(family = "sans")
	)
```

# Forecast comparison

Metric used here is sMAPE, Symmetric Mean Absolute Percentage Error. 
It was chosen, because it is unit indifferent and it calculates 
negative errors with the same weight as the positive ones.     

The results are good, sMAPE of *4.3%* for ARIMA and *3.4%* for
VAR are very solid. It can be seen, that is this situation 
the VAR model performed significantly better then ARIMA.   

The differences between BTC and ETH within both models 
were insignificant, which hints that these type of models 
could be used with other crypto currencies. 

```{r forecast_comparison}
forecast.arima.btc <- forecast(BTC.arima2010.small, h = 30) %>% 
	.$mean %>%
	as.vector()

forecast.arima.eth <- forecast(ETH.arima5120.small, h = 30) %>% 
	.$mean %>%
	as.vector()

forecast.var.btc <- var.forecast[["fcst"]][["btc"]] %>%
	as.data.frame() %>%
	.$fcst

forecast.var.eth <- var.forecast[["fcst"]][["eth"]] %>%
	as.data.frame() %>%
	.$fcst

forecast.comparison <- data.frame(
	btc_real = data_test$btc,
	btc_arima = forecast.arima.btc,
	btc_var = forecast.var.btc,
	eth_real = data_test$eth,
	eth_arima = forecast.arima.eth,
	eth_var = forecast.var.eth
)

data.frame(
	ARIMA_BTC = smape(forecast.comparison$btc_real, forecast.comparison$btc_arima),
	ARIMA_ETH = smape(forecast.comparison$eth_real, forecast.comparison$eth_arima),
	VAR_BTC   = smape(forecast.comparison$btc_real, forecast.comparison$btc_var),
	VAR_ETH   = smape(forecast.comparison$eth_real, forecast.comparison$eth_var)
)
```


# Conclusion






